import { useState, useCallback } from 'react';

/**
 * useUndoRedoState
 * @description Setstate but can also undo and redo
 * @see {@link https://rooks.vercel.app/docs/useUndoRedoState}
 */
function isFunctionInitializer(functionToCheck) {
    return typeof functionToCheck === "function";
}
/**
 * useUndoRedoState hook
 *
 * This hook manages the state with undo and redo capabilities.
 *
 * @param initialState - The initial state value
 * @param options - An optional object with a `maxDepth` property to limit the history and future arrays
 * @returns A tuple with the current state, a function to update the state, and an object with undo and redo controls
 *
 * @example
 * const [state, setState, controls] = useUndoRedoState(0, { maxDepth: 3 });
 * // state is 0
 * setState(1); // state is 1
 * controls.undo(); // state is 0
 * controls.redo(); // state is 1
 */
function useUndoRedoState(initialState, options) {
    var _a;
    const [state, _setState] = useState(initialState);
    const [past, setPast] = useState([]);
    const [future, setFuture] = useState([]);
    const maxDepth = (_a = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _a !== void 0 ? _a : 100;
    const undo = useCallback(() => {
        setPast((pastStates) => {
            const newPast = [...pastStates];
            const previousState = newPast.pop();
            if (typeof previousState !== "undefined") {
                setFuture((futureStates) => [state, ...futureStates]);
                _setState(previousState);
            }
            return newPast;
        });
    }, [state]);
    const redo = useCallback(() => {
        setFuture((futureStates) => {
            const newFuture = [...futureStates];
            const nextState = newFuture.shift();
            if (typeof nextState !== "undefined") {
                setPast((pastStates) => [...pastStates, state]);
                _setState(nextState);
            }
            return newFuture;
        });
    }, [state]);
    const canUndo = useCallback(() => past.length > 0, [past]);
    const canRedo = useCallback(() => future.length > 0, [future]);
    const setState = useCallback((value) => {
        const nextState = isFunctionInitializer(value) ? value(state) : value;
        setPast((pastStates) => {
            const newPast = [...pastStates, state];
            if (newPast.length > maxDepth) {
                newPast.shift();
            }
            return newPast;
        });
        setFuture([]);
        _setState(nextState);
    }, [state, maxDepth]);
    const controls = {
        undo,
        redo,
        canUndo,
        canRedo,
    };
    return [state, setState, controls];
}

export { useUndoRedoState };
